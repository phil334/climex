% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extremes.R
\name{upper.limit.numeric}
\alias{upper.limit.numeric}
\title{Calculation of the upper limit.}
\usage{
\method{upper.limit}{numeric}(x, error.estimation = c("none", "MC",
  "MLE", "bootstrap"), model = c("gev", "gpd"),
  monte.carlo.sample.size = 100, bootstrap.sample.size = 100,
  threshold = NULL, extreme.type = c("max", "min"), mc.cores = NULL)
}
\arguments{
\item{x}{A numerical vector containing the parameters of the
GEV/GP distribution. If \emph{model} is set to \emph{"gev"},
three parameters have to be provided in the following order: c(
location, scale, shape ). If \emph{model} is \emph{"gpd"}
instead, c( scale, shape ) and the \emph{threshold} variable
have to be supplied.}

\item{error.estimation}{Method for calculating the standard error
  of the upper limit. 

  For all  three methods  of estimating the  fitting error  of the
  upper  limit an  underlying series  of threshold  exceedances or
  block maxima  is required. In  case the user  supplies numerical
  values to  specify the GEV/GP  parameters and not the  output of
  either   the   \code{\link{fit.gev}}  or   \code{\link{fit.gpd}}
  function, no error estimation can be performed.

  \emph{MLE}: The variances of the GEV/GP parameters will
    be calculated as the square roots of the diagonal elements of
    the inverse of the hessian matrix evaluated
    at the Maximum Likelihood estimates (MLE) of the GEV/GP
    parameters, the so-called observed information matrix.
    The standard error of the upper limit is
    calculated using error propagation and multiplying the
    gradient of the equation for the upper limit to both sides of
    its inverse.

    Sometimes the  inversion of  the hessian fails  (because there
    are  some  NaN in  the  hessian)  when calculating  the  error
    estimates using  the Maximum  Likelihood approach  (MLE). This
    might   happen  especially   with   older   versions  of   the
    \strong{optim}  package. In  such cases  the Monte  Carlo (MC)
    method is used as a fallback.

  \emph{MC}:  Alternatively one can  use a Monte Carlo  method for
    which  \strong{monte.carlo.sample.size}  samples of  the  same
    length as \strong{x} will be  drawn from a GEV/GP distribution
    constituted by  the obtained MLE  of the GEV/GP  parameters of
    \strong{x}.  The standard  error  is then  calculated for  the
    upper limits of all sampled  series. Note: In its essence this
    approach is not an estimation of the error involved in fitting
    the time  series to  a GEV/GP distribution.  It is  rather the
    mean  error of  fitting  a GEV/GP-distribution  with the  same
    length and parameters as estimated ones.

  \emph{bootstrap}:  Using this  option the provided  time series
    \strong{x}     will     be    sampled     with     replacement
    \strong{bootstrap.sample.size} times and  with the same length
    as the original time series.  The standard errors of the upper
    limits of all those sampled series are calculated and returned
    as an estimate of the fitting  error.  Note: Since the data is
    (hopefully)  GEV/GP-distributed, such  a  sampling  has to  be
    treated with a lot of care.

  \emph{none} skips the calculation of the error. Default = "MLE".}

\item{model}{String determining whether to calculate the initial
parameters of the GEV ("gev") or GP ("gpd") function. Default =
"gev"}

\item{monte.carlo.sample.size}{Number of samples used to obtain
the Monte Carlo estimate of the standard error of the fitting.
Default = 100.}

\item{bootstrap.sample.size}{Number of samples with replacements
to drawn from the original series \strong{x} in order to
determine the standard errors for the upper limit. Default = 100.}

\item{threshold}{Optional threshold for the GP model. If present
it will be added to the upper limit to produce a value which
fits to underlying time series. Default = NULL.}

\item{extreme.type}{String indicating whether to calculate the
quantiles at the right ("max") or left ("min") side of the PDF
of the series. Default = "max".}

\item{mc.cores}{A numerical input specifying the number of cores
to use for the multi core application of the function (see
\code{\link[parallel]{detectCores}}). This functionality is only
available if the input is a list of different objects. If NULL,
the function will be calculated classically with only one core.
Default = NULL.}
}
\value{
A list containing the estimates "upper.limit" and their
  standard errors "error" if the input was a fitting object or a
  numerical input. If, on the other hand, the input was a list of
  such objects, the output is a list of the aforementioned list.
}
\description{
Calculates the upper limit and its error estimate for
  Weibull-typed Generalized  Extreme Value distribution  (GEV) and
  Generalized Pareto (GP) distributions (both only in case of
  shape parameters smaller than 0).
}
\details{
Three different ways of calculating the fitting errors
  are supported: The \emph{MLE} option using the error propagation
  of the covariance matrix obtained via the Maximum Likelihood
  estimators, the two statistical methods \emph{MC} and
  \emph{bootstrap} with the former calculating the standard
  deviation of the upper limits fitted to a set Monte Carlo
  samples distributed according to the maximum likelihood
  estimates of the GEV or GP distribution and the latter by using
  samples generated via bootstrap instead.

  Since the upper limit is only defined for shape parameters
  smaller than zero, all upper limits calculated for the bootstrap
  or Monte Carlo samples showing positive shapes have to be
  discarded. This results in a negative bias of estimator. On the
  other hand, this can also lead to an estimate for the fitting
  error if the actual Maximum Likelihood estimate of the shape
  parameter is slightly bigger than zero. Please keep this in mind
  when interpreting the results.

  This function is also capable of working with lists of fit
  or numerical objects.
}
\examples{
fit.results <- fit.gev( block( anomalies( temp.potsdam ) ) )
upper.limit( fit.results, error.estimation = "MLE" )
}
\seealso{
Other extremes: \code{\link{block.list}},
  \code{\link{block.xts}}, \code{\link{block}},
  \code{\link{decluster.list}},
  \code{\link{decluster.xts}}, \code{\link{decluster}},
  \code{\link{extremal.index}}, \code{\link{gev.density}},
  \code{\link{gpd.density}}, \code{\link{qevd}},
  \code{\link{return.level.climex.fit.gev}},
  \code{\link{return.level.climex.fit.gpd}},
  \code{\link{return.level.list}},
  \code{\link{return.level.numeric}},
  \code{\link{return.level}}, \code{\link{revd}},
  \code{\link{rlevd}}, \code{\link{threshold.list}},
  \code{\link{threshold.xts}}, \code{\link{threshold}},
  \code{\link{upper.limit.climex.fit.gev}},
  \code{\link{upper.limit.climex.fit.gpd}},
  \code{\link{upper.limit.list}}, \code{\link{upper.limit}}
}
\concept{extremes}
